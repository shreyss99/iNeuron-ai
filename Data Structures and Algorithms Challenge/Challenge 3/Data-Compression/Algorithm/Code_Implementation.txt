(A) Implementation of Compression Algorithms:
	
	1) ZIP: 
	
		Implementation:
		
		- We have used the in-built Zip module to perform the Zip compression.
		- We initially create a zip file in write mode.
		- Zip uses the DEFLATE algorithm for compression. 
		- We write the output file using input file and compression type as a parameter.
		
		
	2) LZW: 
	   
		Implementation:
		
		- We have used DICTIONARY data structure to store the characters and their corresponding ASCII value from range 0 to 255.
		- We have used a LIST data structure for storing the codes of the data to be compressed.
		- We run a loop till data length and check if the previous and current character of loop is already existing in the dictionary of characters.
		   If yes, we make the previous character as the current value and increment the counter.
		   If no, then we store the previous character in the codes dictionary.
		- We repeat the process and store the character in codes dictionary.


	3) HUFFMAN:
	
		Implementation:
		
		- We use the TREE and PRIORITY QUEUE data structures in Huffman encoding.
		- The frequencies of the data is computed and used to create the Huffman tree using queue.
		- The PRIORITY QUEUE is used to compute the count of elements in the data and then the count and the corresponding character is stored as a node of TREE.
		- The tree node created above is then inserted into the PRIORITY QUEUE.
		- Once the PRIORITY QUEUE is created, we then build the Huffman Tree by combining the nodes in the PRIORITY QUEUE.
		- Next, we have defined some functions in utility class which we use to get the encoded string.
		- We assign the codes (0 or 1). If it is the left child we assign the code 0 else 1 and repeat recursively till the entire node has been given a code.
		- Once the nodes have been given code, we then iterate upon the data and based on the codes assigned earlier encode the string.
		
		
	4) SHANNON-FANO:
		
		- We use the TREE and LIST data structures in Huffman encoding.
		- The frequencies of the data is computed and stored in a node list which is then sorted based on frequency and character.
		- The TREE is built using the nodes LIST and we split the LIST into 2 parts with sum of frequencies in both parts approximately equal.
		- We keep on doing the above step recursively until we get all the singular elements in data and a TREE is created.
		- For creating equal halves, we start from the last node and keep on adding the sum of frequencies and checking if sum of first part is greter than second part.
		- Next, we have defined some functions in utility class which we use to get the encoded string.
		- We assign the codes (0 or 1). If it is the left child we assign the code 0 else 1 and repeat recursively till the entire node has been given a code.
		- We iterate upon the data and based on the codes assigned earlier encode the string.
		
		
		   
	   

	


