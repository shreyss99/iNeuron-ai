(A) Implementation of Compression Algorithms:
	
	1) ZIP: 
	
		Implementation:
		
		- We have used the in-built Zip module to perform the Zip compression.
		- We initially create a zip file in write mode.
		- Zip uses the DEFLATE algorithm for compression. 
		- We write the output file using input file and compression type as a parameter.
		
		
	2) LZW: 
	   
		Implementation:
		
		- We have used DICTIONARY data structure to store the characters and their corresponding ASCII value from range 0 to 255.
		- We have used a LIST data structure for storing the codes of the data to be compressed.
		- We run a loop till data length and check if the previous and current character of loop is already existing in the dictionary of characters.
		   If yes, we make the previous character as the current value and increment the counter.
		   If no, then we store the previous character in the codes dictionary.
		- We repeat the process and store the character in codes dictionary.


	3) HUFFMAN:
	
		Implementation:
		
		- We use the TREE and PRIORITY QUEUE data structures in Huffman encoding.
		- The frequencies of the data is computed and used to create the Huffman tree using queue.
		- The PRIORITY QUEUE is used to compute the count of elements in the data and then the count and the corresponding character is stored as a node of TREE.
		- The tree node created above is then inserted into the PRIORITY QUEUE.
		- Once the PRIORITY QUEUE is created, we then build the Huffman Tree by combining the nodes in the PRIORITY QUEUE.
		- Next, we have defined some functions in utility class which we use to get the encoded string.
		- We assign the codes (0 or 1). If it is the left child we assign the code 0 else 1 and repeat recursively till the entire node has been given a code.
		- Once the nodes have been given code, we then iterate upon the data and based on the codes assigned earlier encode the string.
		
		
	4) SHANNON-FANO:
		
		- We use the TREE and LIST data structures in Huffman encoding.
		- The frequencies of the data is computed and stored in a node list which is then sorted based on frequency and character.
		- The TREE is built using the nodes LIST and we split the LIST into 2 parts with sum of frequencies in both parts approximately equal.
		- We keep on doing the above step recursively until we get all the singular elements in data and a TREE is created.
		- For creating equal halves, we start from the last node and keep on adding the sum of frequencies and checking if sum of first part is greter than second part.
		- Next, we have defined some functions in utility class which we use to get the encoded string.
		- We assign the codes (0 or 1). If it is the left child we assign the code 0 else 1 and repeat recursively till the entire node has been given a code.
		- We iterate upon the data and based on the codes assigned earlier encode the string.
		
	
	5) PDF:
	
		- For PDF compression we will be using the ILovePdf API which uses a public key specific to the user in the process.
		- We initialise an object of the above API using the public key and verify_ssl parameter.
		- Then we add the file to be compressed and the output path where compressed file needs to be stored.
		- The compression task is executed and the compressed file gets downloaded at the specified output location.
		
	
	6) IMAGE:
	
		- For compression of image files, we will use the PIL library of Python.
		- We open the image using the PIL open function and store the dimensions of the image.
		- Then we use the resize function from PIL to compress the image.
		- We also use the ANTIALIAS option which reduces the visual defects when high-resolution images are presented in lower-resolution.
		- In addition to this, we also save the compressed image with 100% quality and optimize as True for compression.
		
		
	7) WAV-MP3:
	
		- We use the PyDub module from Python.
		- The AudioSegment inside PyDub can be used to work with audio files.
		- We import the wav file using the AudioSegment.
		- Once imported, we export the file by passing the output filename and format.
		
	
	8) VIDEO:
	
		- The OpenCV library is used in video compression.
		- Using the VideoCapture function, we get it and store its dimensions.
		- the VideoWriter function is used to write the output file and the mp4 video codec is used.
		- Inside the loop extract all the frames of the video using read() method.
		- Pass these frame along with the compression size to a rescaling function.
		- It returns the resized frame as per the users compression input using resize method.
		
		